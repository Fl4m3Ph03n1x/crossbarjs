<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"crossbar.js.html":{"id":"crossbar.js.html","title":"Source: crossbar.js","body":" DocStrap Modules crossbarFacade Global Global Source: crossbar.js const isString = require( &quot;lodash.isstring&quot; ); const isFunction = require( &quot;lodash.isfunction&quot; ); const autobahn = require( &quot;autobahn&quot; ); /** * @typedef RPC * @type {Object} * @property {string} name The name of the RPC. * @property {function} func The function to execute. */ /** * @typedef options * @type {Object} * @property {Object} connect See {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#connection-options|connection options} * @property {string} [connect.url=&quot;ws://localhost:8080/ws&quot;] Crossbar &quot;url&quot; to connect to. * @property {string} [connect.realm=&quot;realm1&quot;] Crossbar &quot;realm&quot; for the &quot;url&quot;. * @property {Object} [publish={}] See {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#publish|publish options} * @property {Object} [subscribe={}] See {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#subscribe|subscribe options} * @property {Object} [call={}] See {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#call|call options} * @property {Object} [register={}] See {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#register|register options} */ /** * @public * @author Pedro Miguel P. S. Martins * @version 1.2.0 * @module crossbarFacade * @desc * Encapsulates crossbar publish/subscribe and register/unregister/call functionality into a facade, easier to use and reason about. */ const crossbarFacade = () =&gt; { const DEFAULT_OPTS = Object.freeze( { connect: { &quot;url&quot;: &quot;ws://localhost:8080/ws&quot;, &quot;realm&quot;: &quot;realm1&quot; }, publish: {}, subscribe: {}, call: {}, register: {} } ); const subscritionMap = new Map(), registrationMap = new Map(); let connection, options = Object.assign( {}, DEFAULT_OPTS ); /** * @public * @function connect * @param {Object=} [connectOpts] Connection object with the * options to connect. * The provided Object must have both * an &lt;code&gt;url&lt;/code&gt; and a * &lt;code&gt;realm&lt;/code&gt; properties to * properly connect or else it fails. * If no object is passed, the * function will use the default object. * @param {string} [connectOpts.url = &quot;ws://localhost:8080/ws&quot;] The connection 'url' as described in autobahn connection options. * @param {string} [connectOpts.realm = &quot;realm1&quot;] The connection 'realm' as described in autobahn connection options. * @returns {Promise} * * @description * Connects this instance to the given direction. * Resolves if a connection is established **and** opened successfully. * If it fails to open the connection, it rejects with a reason and an optional details object. * * @see {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#connection-options|autobahn-js connection options} * * @example &lt;caption&gt;Creates a connection with the default parameters:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * crossbar.connect() * .then(() =&gt; console.log(&quot;Great Success!&quot;)) * .catch((reason, details) =&gt; { * console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); * }); * * @example &lt;caption&gt;Creates a connections with custom parameters:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * const connectParams = {url: &quot;myURL&quot;, realm: &quot;Lovecraft&quot;}; * crossbar.connect(connectParams) * .then(() =&gt; console.log(&quot;Great Success!&quot;)) * .catch((reason, details) =&gt; { * console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); * }); * * @example &lt;caption&gt;Additionally, you may also change the &quot;options.connect&quot;:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * * crossbar.setOpts({ * connect: { url: &quot;myURL&quot;, realm: &quot;Lovecraft&quot; } * }); * * crossbar.connect() * .then(() =&gt; console.log(&quot;Great Success!&quot;)) * .catch((reason, details) =&gt; { * console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); * }); */ const connect = function ( connectOpts = options.connect ) { return new Promise( ( resolve, reject ) =&gt; { connection = new autobahn.Connection( connectOpts ); connection.onopen = () =&gt; { events.onOpen(); resolve(); connection.onopen = () =&gt; { events.onOpen(); recover() .then( events.onRecover ) .catch( events.onError ); }; }; connection.onclose = ( reason, details ) =&gt; { events.onClose( reason, details ); reject( reason, details ); connection.onclose = events.onClose; }; connection.open(); } ); }; const recover = () =&gt; recoverFromMap( &quot;subscribe&quot;, subscritionMap ) .then( () =&gt; recoverFromMap( &quot;register&quot;, registrationMap ) ); const recoverFromMap = async function ( action, map ) { for ( const [ key, data ] of map ) { await add( action, key, data.cb, options[ action ], { set: () =&gt; {} } ).catch( err =&gt; events.onError( err ) ); } }; const events = { onClose: () =&gt; {}, onOpen: () =&gt; {}, onRecover: () =&gt; {}, onError: () =&gt; {} }; /** * @public * @function onClose * @param {function} fun The function to be called when a connection closes. * @throws {TypeError} If &lt;code&gt;fun&lt;/code&gt; is not a function. * * @description * Hook for when the connection closes. This usually happens when crossbar itself dies or closes its connections. * The passed function will receive 2 parameters, &lt;code&gt;reason&lt;/code&gt;, a human readable reason for why the connection was closed, and a second optional parameter &lt;code&gt;details&lt;/code&gt;, an object containing the details of why the connection was closed. This second parameter is not always passed. * * @example &lt;caption&gt;Creating a hook that logs when a connection was closed:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * crossbar.connect() * .then(() =&gt; crossbar.onClose(console.log)) //if crossbar dies, this gets fired * .catch((reason, details) =&gt; { * console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); * }); */ const onClose = fun =&gt; { if ( !isFunction( fun ) ) throw new TypeError( `${fun} must be a Function.` ); events.onClose = fun; }; /** * @public * @function onOpen * @param {function} fun The function to be called when a connection opens. * @throws {TypeError} If &lt;code&gt;fun&lt;/code&gt; is not a function. * * @description * Hook for when the connection opens. This usually happens when the application first connects to crossbar and when the connection is lost and later on recovered. * The passed function will receive no parameters. * * @example &lt;caption&gt;Creating a hook that logs when a connection opens:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * crossbar.onOpen(() =&gt; console.log(&quot;I'm alive!&quot;)); * crossbar.connect() * .catch((reason, details) =&gt; { * console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); * }); */ const onOpen = fun =&gt; { events.onOpen = fun; }; /** * @public * @function onRecover * @param {function} fun The function to be called when a connection recovers. * @throws {TypeError} If &lt;code&gt;fun&lt;/code&gt; is not a function. * * @description * Hook for when the connection recovers. A connection recovers when it has closed unexpectadly and then reconnects activating the recover proceaduer, that re-subscribes and re-registers any calls previously done automatically. * The passed function will receive no parameters. * * @example &lt;caption&gt;Creating a hook that logs when a connection recovers:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * crossbar.onRecover(() =&gt; console.log(&quot;I'm back baby!&quot;)); * crossbar.connect() * .catch((reason, details) =&gt; { * console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); * }); * //kill crossbar * //start crossbar * //message should appear */ const onRecover = fun =&gt; { events.onRecover = fun; }; /** * @public * @function onError * @param {function} fun The function to be called when an Error occurs. * @throws {TypeError} If &lt;code&gt;fun&lt;/code&gt; is not a function. * * @description * Hook for when an error occurs. Errors may occur when crossbarjs is attempting automatic reconnection or becasue some other component failed. * The passed function will receive the &lt;code&gt;error&lt;/code&gt; as a parameter. * * @example &lt;caption&gt;Creating a hook that logs when an error occurs:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * crossbar.onRecover(error =&gt; console.log(`Got error: ${error}`)); */ const onError = fun =&gt; { events.onError = fun; }; /** * @public * @function disconnect * @param {string} [reason=&quot;wamp.goodbye.normal&quot;] WAMP URI providing a closing reason e.g. 'com.myapp.close.signout' to the server side. * @param {string} [message] Human-readable closing message. * @returns {Promise} * * @description * Closes the crossbar connection. Resolves once the connection is closed or rejects if there was an error closing. * * @example &lt;caption&gt;Simply disconnect:&lt;/caption&gt; * * //imagine we have previously connected * crossbar.disconnect() * .then(() =&gt; console.log(&quot;disconnected!&quot;)) * .catch(console.log); * * @example &lt;caption&gt;Disconnect after connecting:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * crossbar.connect() * .then(() =&gt; console.log(&quot;connected!&quot;)) * .then(() =&gt; crossbar.disconnect(&quot;com.myapp.close.signout&quot;, &quot;client does not like our service !!!!&quot;)) * .then(() =&gt; console.log(&quot;disconnected!&quot;)) * .catch(console.log); * * @example &lt;caption&gt;Error while disconnecting:&lt;/caption&gt; * const crossbarjs = require(&quot;crossbarjs&quot;); * * const crossbar = crossbarjs(); * crossbar.disconnect() * .catch(console.log); //error, we never connected in the first place! */ const disconnect = function ( reason, message ) { return new Promise( ( resolve, reject ) =&gt; { connection.onclose = resolve; try { connection.close( reason, message ); } catch ( error ) { reject( error ); } } ); }; /** * @public * @function getSession * @returns {Session} * * @description * Returns the current autobahn.Session object. * Ideally you shouldn't need to use it with the current interface, but in case you need you can have direct access to it. * * @see {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#sessions|autobahn-js sessions} * * @example &lt;caption&gt;Using a session:&lt;/caption&gt; * //Assuming we have previously connected * const session = crossbar.getSession(); * console.log(`Session id is: ${session.id}`); */ const getSession = function () { return connection.session; }; /** * @public * @function getConnection * @returns {Connection} * * @description Returns the current autobahn.Connection object. * * @see {@link https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#connections|autobahn-js connections} * * @example &lt;caption&gt;Using a connection:&lt;/caption&gt; * //Assuming we have previously connected * const conn = crossbar.getConnection(); */ const getConnection = function () { return connection; }; /** * @public * @function register * @param {(string|RPC[])} args It can either receive two arguments, * a string and a function, to register * one RPC, or it can receive an array of * RPC objects, to register them all. * @returns {Promise} * * @description * Registers the given RPCs, biinding each RPC to a name. * It can either register a single RPC, or an array of RPC objects. * Resolves if all RPCs were registered successfully or rejects if one of them fails. * * @example &lt;caption&gt;Registering a single RPC:&lt;/caption&gt; * //Assuming we have previously connected * const myHello = () =&gt; { * console.log(&quot;Hello World&quot;); * } * * crossbar.register(&quot;hello&quot;, myHello) * .then(() =&gt; console.log(&quot;great success!&quot;)) * .catch(console.log); * * @example &lt;caption&gt;Registering multiple RPCs:&lt;/caption&gt; * //Assuming we have previously connected * const myHello = () =&gt; { * console.log(&quot;Hello World&quot;); * } * * const myGoodbye = () =&gt; { * console.log(&quot;Goodbye World!&quot;); * }; * * const RPCs = [ * { name: &quot;hello&quot; , func: myHello }, * { name: &quot;bye&quot; , func: myGoodbye } * ]; * * crossbar.register(RPCs) * .then(() =&gt; console.log(&quot;great success!&quot;)) * .catch(console.log); */ const register = function ( ...args ) { const argsArray = Array.from( args ); if ( Array.isArray( argsArray[ 0 ] ) ) return registerMany( argsArray[ 0 ] ); if ( isString( argsArray[ 0 ] ) &amp;&amp; isFunction( argsArray[ 1 ] ) &amp;&amp; argsArray.length === 2 ) return registerOne( argsArray[ 0 ], argsArray[ 1 ] ); return Promise.reject( new Error( &quot;Unrecognized parameters&quot; ) ); }; const registerOne = function ( name, func ) { if ( !isString( name ) ) { return Promise.reject( new TypeError( `${name} must be a String.` ) ); } if ( !isFunction( func ) ) { return Promise.reject( new TypeError( `${func} must be a Function.` ) ); } return add( &quot;register&quot;, name, deCrossbarify( func ), options.register, registrationMap ); }; const registerMany = async function ( rpcList ) { for ( const rpc of rpcList ) { await registerOne( rpc.name, rpc.func ) .catch( err =&gt; { throw new Error( `Failed to register &quot;${rpc.name}&quot;: ${JSON.stringify(err)}` ); } ); } }; /** * @public * @function unregister * @param {...string} args The names of the RPCs to unregister * @returns {Promise} * * @description * Unregisters the RPC with the given name, or all the RPCs with the names provided in the array. * Returns a promise once all RPCs have be unregistered successfully or rejects if one of them fails. * * @example &lt;caption&gt;Unregister a single RPC:&lt;/caption&gt; * //Assuming we have previously connected and registered &quot;hello&quot; * crossbar.unregister(&quot;hello&quot;) * .then(() =&gt; console.log(&quot;great success!&quot;)) * .catch(console.log); * * @example &lt;caption&gt;Unregister multiple RPCs:&lt;/caption&gt; * //Assuming we have previously connected and registered the RPCs with the given names * crossbar.unregister(&quot;hello&quot;, &quot;bye&quot;) * .then(() =&gt; console.log(&quot;great success!&quot;)) * .catch(console.log); */ const unregister = function ( ...args ) { return unregisterMany( args ); }; const unregisterOne = function ( name ) { if ( !isString( name ) ) { return Promise.reject( new TypeError( `${name} must be a String.` ) ); } if ( !registrationMap.has( name ) ) { return Promise.reject( new Error( `${name} is not registered.` ) ); } return remove( &quot;unregister&quot;, name, registrationMap ); }; const unregisterMany = async function ( rpcNamesList ) { for ( const rpcName of rpcNamesList ) { await unregisterOne( rpcName ) .catch( err =&gt; { throw new Error( `Failed to unregister &quot;${rpcName.name}&quot;: ${JSON.stringify(err)}` ); } ); } }; /** * @public * @function call * @param {string} rpcName The name of the RPC we wish to call. * @param {...Object} args Variable number of arguments we wish to * pass. * @returns {Promise} * * @description * Calls the RPC with the given name, providing the given arguments. * Resolves if it succeeds, rejects otherwise. * * @example &lt;caption&gt;Call an RPC with no arguments:&lt;/caption&gt; * //Assuming we have previously connected and registered the RPC &quot;hello&quot; * * const hello = () =&gt; { * console.log(&quot;Hello World&quot;); * }; * * crossbar.call(&quot;hello&quot;) * .then(() =&gt; console.log(&quot;great success!&quot;)) * .catch(console.log); * * @example &lt;caption&gt;Call an RPC with multiple arguments:&lt;/caption&gt; * //Assuming we have previously connected and registered the RPC &quot;add&quot; * * const add = (n1, n2) =&gt; n1 + n2; * * crossbar.call(&quot;add&quot;, 1, 2) * .then(sum =&gt; console.log(`sum is: ${sum}`)) * .catch(console.log); */ const call = function ( rpcName, ...args ) { try { return getSession().call( rpcName, args, {}, options.call ); } catch ( error ) { return Promise.reject( error ); } }; /** * @public * @function getOpts * @returns {options} * * @description Returns a clone of the options object. * * @example &lt;caption&gt;Get a clone of the options object:&lt;/caption&gt; * let opts = crossbar.getOpts(); * opts = {}; //this wont alter the object being used in crossbarjs */ const getOpts = function () { return Object.assign( {}, options ); }; /** * @public * @function setOpts * @param {Object} newOpts The options we want to add. * * @description * Concatenates the given options object with the current one. * This is the only way to change the &lt;code&gt;options&lt;/code&gt; object. * * @see {options} * * @example &lt;caption&gt;Add publish parameters to the options object:&lt;/caption&gt; * crossbar.setOpts({ * publish: { some options } * }); * console.log(JSON.stringify(crossbar.getOpts())); * //will print * //{ * // connect: { * // &quot;url&quot;: &quot;ws://localhost:8080/ws&quot;, * // &quot;realm&quot;: &quot;realm1&quot; * // }, * // publish: { some options }, * // subscribe: {}, * // call: {}, * // register: {} * //} */ const setOpts = function ( newOpts ) { Object.assign( options, newOpts ); }; /** * @public * @function setOptsDefault * * @description Resets the options object to its default state. * * @see {options} */ const setOptsDefault = function () { options = Object.assign( {}, DEFAULT_OPTS ); }; /** * @public * @function publish * @param {string} topic The topic of the message. * @param {...Object} params The parameters that the subscribed * functions will receive. * @returns {Promise} * * @description * Publishes the given topic with the given list of variable parameters. * Resolves if it succeeds, rejects otherwise. * * @example &lt;caption&gt;Publish a topic:&lt;/caption&gt; * //Assuming we are already connected * crossbar.publish(&quot;add&quot;, 1, 2) * .then(() =&gt; console.log(&quot;Published!&quot;)) * .catch(console.log); */ const publish = function ( topic, ...params ) { //autobahn-js only returns promise under specific circumstances. We // fix that here. let res; try { res = getSession().publish( topic, params, {}, options.publish ); } catch ( error ) { return Promise.reject( error ); } return options.publish.acknowledge !== undefined ? res : Promise.resolve(); }; /** * @public * @function subscribe * @param {string} topic The topic to wich we want to subscribe. * @param {function} callback The function to execute every time we * receive a message. * @returns {Promise} * * @description * Subscribes to the given topic, executing the function every time crossbar receives a message. * Resolves if the subscription was successful, rejects otherwise. * * @example &lt;caption&gt;Subscribe to the topic &quot;add&quot;. See &lt;code&gt;publish&lt;/code&gt;:&lt;/caption&gt; * //Assuming we are already connected * const myAdd = (n1, n2) =&gt; n1 + n2; * * crossbar.subscribe(&quot;add&quot;, myAdd); * .then(() =&gt; console.log(&quot;Subscribed!&quot;)) * .catch(console.log); */ const subscribe = function ( topic, callback ) { if ( subscritionMap.has( topic ) ) { return Promise.reject( new Error( `Already subscribed to ${topic}` ) ); } return add( &quot;subscribe&quot;, topic, deCrossbarify( callback ), options.subscribe, subscritionMap ); }; /** * @private * @function add * @param {string} action A session's function name to execute. In * theory it should have been the function * itself, but since there were some * context issues, I decided to pass the * function's name and then execute it. * @param {string} id The id of the thing we will be adding. * @param {function} callback The function we associate with the given * id. * @param {Object} options Options object for the action. * @param {Map} map The map that will save the association * betwwen the id and the result of the * action. * @returns {Promise} * * @description * Introduced after codeclimate code quality analysis as a means to remove duplication betwwen regiterOne and subscribe, since they both have the same structure. * */ const add = ( action, id, callback, options, map ) =&gt; { return getSession()[ action ]( id, callback, options ) .then( result =&gt; { map.set( id, { cb: callback, opResult: result } ); } ); }; /** * @private * @function add * @param {string} action A session's function name to execute. In * theory it should have been the function * itself, but since there were some * context issues, I decided to pass the * function's name and then execute it. * @param {string} id The id of the thing we will be removing. * @param {Map} map The map containing the id. * @returns {Promise} * * @description * Introduced after codeclimate code quality analysis as a means to remove duplication betwwen regiterOne and subscribe, since they both have the same structure. * */ const remove = ( action, id, map ) =&gt; { return getSession()[ action ]( map.get( id ).opResult ) .then( () =&gt; { map.delete( id ); } ); }; /** * @private * @function deCrossbarify * @param {function} callback The function with the actual parameters. * @returns {function} * * @description * &lt;p&gt; * To register and subscribe to crossbar events, you either need to have all arguments in an array, or in a object. * This approach is counter intuitive and cumbersome, and many beginners have issues with it. * &lt;/p&gt; * &lt;p&gt; * This function takes the array argument, and spreads it to the given function. * This way people can have functions with all the arguments listed as subscribers and RPCs. * The code is thus cleaner and easier to reason about. * &lt;/p&gt; */ const deCrossbarify = callback =&gt; args =&gt; callback.call( null, ...args ); /** * @public * @function unsubscribe * @param {string} topic The topic to which we want to unsubscribe. * @returns {Promise} * * @description Unsubscribes from the given topic. Resolves if successful, * rejects otherwise. * * @example &lt;caption&gt;Unsubscribe to the topic &quot;add&quot;. See &lt;code&gt;subscribe&lt;/code&gt;:&lt;/caption&gt; * //Assuming we are already connected * crossbar.unsubscribe(&quot;add&quot;); * .then(() =&gt; console.log(&quot;Unsubscribed!&quot;)) * .catch(console.log); */ const unsubscribe = function ( topic ) { if ( !subscritionMap.has( topic ) ) { return Promise.reject( new Error( `Not subscribed to ${topic}` ) ); } return remove( &quot;unsubscribe&quot;, topic, subscritionMap ); }; return Object.freeze( { connect, disconnect, getSession, getConnection, register, unregister, call, setOpts, getOpts, setOptsDefault, publish, subscribe, unsubscribe, onOpen, onClose, onRecover, onError } ); }; module.exports = crossbarFacade; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules crossbarFacade Global Global Global Type Definitions options Type: Object Properties: Name Type Argument Default Description connect Object See connection options Properties Name Type Argument Default Description url string &lt;optional&gt; &quot;ws://localhost:8080/ws&quot; Crossbar &quot;url&quot; to connect to. realm string &lt;optional&gt; &quot;realm1&quot; Crossbar &quot;realm&quot; for the &quot;url&quot;. publish Object &lt;optional&gt; {} See publish options subscribe Object &lt;optional&gt; {} See subscribe options call Object &lt;optional&gt; {} See call options register Object &lt;optional&gt; {} See register options Source: crossbar.js, line 12 RPC Type: Object Properties: Name Type Description name string The name of the RPC. func function The function to execute. Source: crossbar.js, line 5 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules crossbarFacade Global Global Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules crossbarFacade Global Global WhatTechnically speaking crossbarjs is a Facade over autobahn-js. In practice, it is a library whose main purpose is to make interactions with crossbar easier, with support and focus over the 4 main crossbar functionalities and their counterparts: publish subscribe/unsubscribe register/unregister call Without compromising access to any of the more advanced functionalities provided in the layer bellow. Whyautobahn-js API is long and it breaks the principle of least astonishment. To use it you need to go through pages of sparse documentation understand advanced principles of JavaScript. crossbarjs is an attempt at fixing that. The API it provides is as simple and beginner friendly as possible and its purpose is to make sure that all you need to run crossbario is to download this module and run it without spending extra time on docs, as it is designed to be as intuitive as possible. And if you still need some advanced options, you can always use them via an options object. HowFollowing are instructions on how to intsall and use crossbarjs. For more information about the project you can check GitHub page: crossbarjs Github And for questions you can ask in the issues page: crossbarjs Issues Installnpm install crossbarjs --saveExamplesEach method is documented with its own examples. For further usage cases you can check the modules page. Connect and publish a message: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.connect() .then(() =&gt; { crossbar.publish(&quot;myTopic&quot;, &quot;arg1&quot;, &quot;arg2&quot;); }) .catch(console.log);Subscribe to a topic: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.connect() .then(() =&gt; { const print = (str1, str2) =&gt; console.log(`str1 is ${str1}, str2 is ${str2}`); return crossbar.subscribe(&quot;myTopic&quot;, print); }) .catch(console.log);Register a bunch of RPCs: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); //after connecting const print = (str1, str2) =&gt; console.log(`str1 is ${str1}, str2 is ${str2}`); const add3 = (n1, n2, n3) =&gt; n1 + n2 + n3; crossbar.register([ { &quot;print&quot;: func: print }, { &quot;addThreeNumbers&quot; : func: add3 } ]) .then(() =&gt; console.log(&quot;Register successful&quot;)) .catch(console.log);Unregister a bunch of RPCs: //after connecting and registering crossbar.unregister(&quot;print&quot;, &quot;addThreeNumbers&quot;) .then(() =&gt; console.log(&quot;Unregister successful&quot;)) .catch(console.log);Call an RPC: //after connecting and registering crossbar.call(&quot;addThreeNumbers&quot;, 1, 2, 3) .then(res =&gt; console.log(res)) .catch(console.log); × Search results Close "},"module-crossbarFacade.html":{"id":"module-crossbarFacade.html","title":"Module: crossbarFacade","body":" DocStrap Modules crossbarFacade Global Global Module: crossbarFacade Encapsulates crossbar publish/subscribe and register/unregister/call functionality into a facade, easier to use and reason about. Version: 1.2.0 Author: Pedro Miguel P. S. Martins Source: crossbar.js, line 24 Methods &lt;inner&gt; call(rpcName, args) Calls the RPC with the given name, providing the given arguments. Resolves if it succeeds, rejects otherwise. Parameters: Name Type Argument Description rpcName string The name of the RPC we wish to call. args Object &lt;repeatable&gt; Variable number of arguments we wish to pass. Source: crossbar.js, line 469 Returns: Type Promise Examples Call an RPC with no arguments: //Assuming we have previously connected and registered the RPC &quot;hello&quot; const hello = () =&gt; { console.log(&quot;Hello World&quot;); }; crossbar.call(&quot;hello&quot;) .then(() =&gt; console.log(&quot;great success!&quot;)) .catch(console.log); Call an RPC with multiple arguments: //Assuming we have previously connected and registered the RPC &quot;add&quot; const add = (n1, n2) =&gt; n1 + n2; crossbar.call(&quot;add&quot;, 1, 2) .then(sum =&gt; console.log(`sum is: ${sum}`)) .catch(console.log); &lt;inner&gt; connect( [connectOpts]) Connects this instance to the given direction. Resolves if a connection is established and opened successfully. If it fails to open the connection, it rejects with a reason and an optional details object. Parameters: Name Type Argument Description connectOpts Object &lt;optional&gt; Connection object with the options to connect. The provided Object must have both an url and a realm properties to properly connect or else it fails. If no object is passed, the function will use the default object. Properties Name Type Argument Default Description url string &lt;optional&gt; &quot;ws://localhost:8080/ws&quot; The connection 'url' as described in autobahn connection options. realm string &lt;optional&gt; &quot;realm1&quot; The connection 'realm' as described in autobahn connection options. Source: crossbar.js, line 51 See: autobahn-js connection options Returns: Type Promise Examples Creates a connection with the default parameters: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.connect() .then(() =&gt; console.log(&quot;Great Success!&quot;)) .catch((reason, details) =&gt; { console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); }); Creates a connections with custom parameters: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); const connectParams = {url: &quot;myURL&quot;, realm: &quot;Lovecraft&quot;}; crossbar.connect(connectParams) .then(() =&gt; console.log(&quot;Great Success!&quot;)) .catch((reason, details) =&gt; { console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); }); Additionally, you may also change the &quot;options.connect&quot;: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.setOpts({ connect: { url: &quot;myURL&quot;, realm: &quot;Lovecraft&quot; } }); crossbar.connect() .then(() =&gt; console.log(&quot;Great Success!&quot;)) .catch((reason, details) =&gt; { console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); }); &lt;inner&gt; disconnect( [reason] [, message]) Closes the crossbar connection. Resolves once the connection is closed or rejects if there was an error closing. Parameters: Name Type Argument Default Description reason string &lt;optional&gt; &quot;wamp.goodbye.normal&quot; WAMP URI providing a closing reason e.g. 'com.myapp.close.signout' to the server side. message string &lt;optional&gt; Human-readable closing message. Source: crossbar.js, line 252 Returns: Type Promise Examples Simply disconnect: //imagine we have previously connected crossbar.disconnect() .then(() =&gt; console.log(&quot;disconnected!&quot;)) .catch(console.log); Disconnect after connecting: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.connect() .then(() =&gt; console.log(&quot;connected!&quot;)) .then(() =&gt; crossbar.disconnect(&quot;com.myapp.close.signout&quot;, &quot;client does not like our service !!!!&quot;)) .then(() =&gt; console.log(&quot;disconnected!&quot;)) .catch(console.log); Error while disconnecting: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.disconnect() .catch(console.log); //error, we never connected in the first place! &lt;inner&gt; getConnection() Returns the current autobahn.Connection object. Source: crossbar.js, line 317 See: autobahn-js connections Returns: Type Connection Example Using a connection: //Assuming we have previously connected const conn = crossbar.getConnection(); &lt;inner&gt; getOpts() Returns a clone of the options object. Source: crossbar.js, line 509 Returns: Type options Example Get a clone of the options object: let opts = crossbar.getOpts(); opts = {}; //this wont alter the object being used in crossbarjs &lt;inner&gt; getSession() Returns the current autobahn.Session object. Ideally you shouldn't need to use it with the current interface, but in case you need you can have direct access to it. Source: crossbar.js, line 297 See: autobahn-js sessions Returns: Type Session Example Using a session: //Assuming we have previously connected const session = crossbar.getSession(); console.log(`Session id is: ${session.id}`); &lt;inner&gt; onClose(fun) Hook for when the connection closes. This usually happens when crossbar itself dies or closes its connections.The passed function will receive 2 parameters, reason, a human readable reason for why the connection was closed, and a second optional parameter details, an object containing the details of why the connection was closed. This second parameter is not always passed. Parameters: Name Type Description fun function The function to be called when a connection closes. Source: crossbar.js, line 155 Throws: If fun is not a function. Type TypeError Example Creating a hook that logs when a connection was closed: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.connect() .then(() =&gt; crossbar.onClose(console.log)) //if crossbar dies, this gets fired .catch((reason, details) =&gt; { console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); }); &lt;inner&gt; onError(fun) Hook for when an error occurs. Errors may occur when crossbarjs is attempting automatic reconnection or becasue some other component failed.The passed function will receive the error as a parameter. Parameters: Name Type Description fun function The function to be called when an Error occurs. Source: crossbar.js, line 232 Throws: If fun is not a function. Type TypeError Example Creating a hook that logs when an error occurs: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.onRecover(error =&gt; console.log(`Got error: ${error}`)); &lt;inner&gt; onOpen(fun) Hook for when the connection opens. This usually happens when the application first connects to crossbar and when the connection is lost and later on recovered.The passed function will receive no parameters. Parameters: Name Type Description fun function The function to be called when a connection opens. Source: crossbar.js, line 181 Throws: If fun is not a function. Type TypeError Example Creating a hook that logs when a connection opens: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.onOpen(() =&gt; console.log(&quot;I'm alive!&quot;)); crossbar.connect() .catch((reason, details) =&gt; { console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); }); &lt;inner&gt; onRecover(fun) Hook for when the connection recovers. A connection recovers when it has closed unexpectadly and then reconnects activating the recover proceaduer, that re-subscribes and re-registers any calls previously done automatically.The passed function will receive no parameters. Parameters: Name Type Description fun function The function to be called when a connection recovers. Source: crossbar.js, line 205 Throws: If fun is not a function. Type TypeError Example Creating a hook that logs when a connection recovers: const crossbarjs = require(&quot;crossbarjs&quot;); const crossbar = crossbarjs(); crossbar.onRecover(() =&gt; console.log(&quot;I'm back baby!&quot;)); crossbar.connect() .catch((reason, details) =&gt; { console.log(`Failed becasue ${reason}: ${JSON.stringify(details)}`); }); //kill crossbar //start crossbar //message should appear &lt;inner&gt; publish(topic, params) Publishes the given topic with the given list of variable parameters. Resolves if it succeeds, rejects otherwise. Parameters: Name Type Argument Description topic string The topic of the message. params Object &lt;repeatable&gt; The parameters that the subscribed functions will receive. Source: crossbar.js, line 568 Returns: Type Promise Example Publish a topic: //Assuming we are already connected crossbar.publish(&quot;add&quot;, 1, 2) .then(() =&gt; console.log(&quot;Published!&quot;)) .catch(console.log); &lt;inner&gt; register(args) Registers the given RPCs, biinding each RPC to a name. It can either register a single RPC, or an array of RPC objects. Resolves if all RPCs were registered successfully or rejects if one of them fails. Parameters: Name Type Description args string | Array.&lt;RPC&gt; It can either receive two arguments, a string and a function, to register one RPC, or it can receive an array of RPC objects, to register them all. Source: crossbar.js, line 334 Returns: Type Promise Examples Registering a single RPC: //Assuming we have previously connected const myHello = () =&gt; { console.log(&quot;Hello World&quot;); } crossbar.register(&quot;hello&quot;, myHello) .then(() =&gt; console.log(&quot;great success!&quot;)) .catch(console.log); Registering multiple RPCs: //Assuming we have previously connected const myHello = () =&gt; { console.log(&quot;Hello World&quot;); } const myGoodbye = () =&gt; { console.log(&quot;Goodbye World!&quot;); }; const RPCs = [ { name: &quot;hello&quot; , func: myHello }, { name: &quot;bye&quot; , func: myGoodbye } ]; crossbar.register(RPCs) .then(() =&gt; console.log(&quot;great success!&quot;)) .catch(console.log); &lt;inner&gt; setOpts(newOpts) Concatenates the given options object with the current one. This is the only way to change the options object. Parameters: Name Type Description newOpts Object The options we want to add. Source: crossbar.js, line 524 See: {options} Example Add publish parameters to the options object: crossbar.setOpts({ publish: { some options } }); console.log(JSON.stringify(crossbar.getOpts())); //will print //{ // connect: { // &quot;url&quot;: &quot;ws://localhost:8080/ws&quot;, // &quot;realm&quot;: &quot;realm1&quot; // }, // publish: { some options }, // subscribe: {}, // call: {}, // register: {} //} &lt;inner&gt; setOptsDefault() Resets the options object to its default state. Source: crossbar.js, line 556 See: {options} &lt;inner&gt; subscribe(topic, callback) Subscribes to the given topic, executing the function every time crossbar receives a message. Resolves if the subscription was successful, rejects otherwise. Parameters: Name Type Description topic string The topic to wich we want to subscribe. callback function The function to execute every time we receive a message. Source: crossbar.js, line 599 Returns: Type Promise Example Subscribe to the topic &quot;add&quot;. See publish: //Assuming we are already connected const myAdd = (n1, n2) =&gt; n1 + n2; crossbar.subscribe(&quot;add&quot;, myAdd); .then(() =&gt; console.log(&quot;Subscribed!&quot;)) .catch(console.log); &lt;inner&gt; unregister(args) Unregisters the RPC with the given name, or all the RPCs with the names provided in the array. Returns a promise once all RPCs have be unregistered successfully or rejects if one of them fails. Parameters: Name Type Argument Description args string &lt;repeatable&gt; The names of the RPCs to unregister Source: crossbar.js, line 417 Returns: Type Promise Examples Unregister a single RPC: //Assuming we have previously connected and registered &quot;hello&quot; crossbar.unregister(&quot;hello&quot;) .then(() =&gt; console.log(&quot;great success!&quot;)) .catch(console.log); Unregister multiple RPCs: //Assuming we have previously connected and registered the RPCs with the given names crossbar.unregister(&quot;hello&quot;, &quot;bye&quot;) .then(() =&gt; console.log(&quot;great success!&quot;)) .catch(console.log); &lt;inner&gt; unsubscribe(topic) Unsubscribes from the given topic. Resolves if successful, rejects otherwise. Parameters: Name Type Description topic string The topic to which we want to unsubscribe. Source: crossbar.js, line 705 Returns: Type Promise Example Unsubscribe to the topic &quot;add&quot;. See subscribe: //Assuming we are already connected crossbar.unsubscribe(&quot;add&quot;); .then(() =&gt; console.log(&quot;Unsubscribed!&quot;)) .catch(console.log); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
